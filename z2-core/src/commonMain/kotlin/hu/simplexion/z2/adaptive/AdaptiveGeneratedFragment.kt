/*
 * Copyright Â© 2020-2024, Simplexion, Hungary and contributors. Use of this source code is governed by the Apache 2.0 license.
 */
package hu.simplexion.z2.adaptive

/**
 * Interface to implement by fragments generated by the compiler plugin.
 * This interface may define functions the generated fragments use, so
 * we do not have to code them in IR.
 */
abstract class AdaptiveGeneratedFragment<BT>(
    final override val adapter: AdaptiveAdapter<BT>,
    override val parent: AdaptiveFragment<BT>?,
    override val index: Int,
    stateSize: Int
) : AdaptiveFragment<BT> {

    override val id = adapter.newId()

    override val state = arrayOfNulls<Any?>(stateSize)

    override var dirtyMask = adaptiveInitStateMask

    @Suppress("LeakingThis") // closure won't do anything with components during init
    override val thisClosure = AdaptiveClosure(arrayOf(this), stateSize)

    var containedFragment: AdaptiveFragment<BT>? = null

    override fun invoke(supportFunction: AdaptiveSupportFunction<BT>, arguments: Array<out Any?>): Any? {
        if (adapter.trace) trace(supportFunction, arguments)
        return null // overwritten by the plugin
    }

    override fun create() {
        if (adapter.trace) trace("create")

        patch()

        containedFragment = build(this, 0)

        dirtyMask = adaptiveCleanStateMask
    }

    override fun mount(bridge: AdaptiveBridge<BT>) {
        if (adapter.trace) trace("mount", bridge)
        containedFragment?.mount(bridge)
    }

    override fun patchExternal() {
        if (adapter.trace) traceWithState("beforePatchExternal")
        createClosure?.owner?.patchDescendant(this)
        if (adapter.trace) traceWithState("afterPatchExternal")
    }

    override fun patchInternal() {
        patchInternalStart()
        patchInternalEnd()
    }

    fun patchInternalStart() {
        if (adapter.trace) traceWithState("beforePatchInternal")
    }

    fun patchInternalEnd() {
        containedFragment?.patch()
        if (adapter.trace) traceWithState("afterPatchInternal")
        dirtyMask = adaptiveCleanStateMask
    }

    override fun unmount(bridge: AdaptiveBridge<BT>) {
        if (adapter.trace) trace("unmount", bridge)
        containedFragment?.unmount(bridge)
    }

    override fun dispose() {
        if (adapter.trace) trace("dispose")
        containedFragment?.dispose()
    }

    override fun toString(): String =
        "${this::class.simpleName ?: "<unknown>"}@$id"
}